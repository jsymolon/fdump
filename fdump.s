;**********************************************
;* P8 FILE DUMP DEMO PROGRAM *
;* CA65 ASSEMBLER
;***********************************************
			.segment "STARTUP"
			.segment "CODE"
			.org $2000
 
; Set High Bit on char
.macro hiasc str
.repeat .strlen(str),I
.byte .strat(str,I) | $80
.endrep
.endmacro

			;DSK FDUMP.SYS
			;TYP $FF 			; SYSTEM FILE TYPE

MLI 		= $BF00		; STD. PRODOS 8 ENTRY
COUT 		= $FDED
HOME		= $FC58
RDKEY		= $FD0C		; MONITOR READ KEY ROUTINE
GETLN2 	= $FD6F 		; MONITOR INPUT ROUTINE W/0 PROMPT
INBUF 	= $200 		; INPUT BUFFER
PRBYTE 	= $FDDA		; PRINT ACC. AS HEX NUMBER
RD80COL 	= $C01F 		; BIT 7 = I = 80 COLS. "ON"
WNDWDTH 	= $21 			; TEXT WINDOW WIDTH
CH80 		= $578 		; 80-COL HORIZ. CURSOR POSN



SETQUIT:	LDA #$4C 		; JMP INSTRUCTION
			STA $3F8 		; CTRLY VECTOR
			LDA #<QUIT 		; WW BYTE OF QUIT ADDR.
			STA $3F9 		; WW BYTE OF CTRL-Y VECTOR
			LDA #>QUIT 	
			STA $3FA 		; HIGH BYTE OF CTRL-Y VECTOR

BEGIN: 	BIT RD80COL 	; 80 COLS ACTIVE?
			BMI CLEAR 	   ; YES
			LDA #40 			; WINDOW WIDTH
			STA WNDWDTH 	; SET WIDTH, JUST IN CASE
			STZ CH80 	 	; SET 80 COL CURSOR H = 0

CLEAR:	JSR HOME 		; CLEAR SCREEN

PROMPT: 	LDY #$00 		; !NIT Y-REG
@1: 		LDA MSSG1,Y 	; PRINT PROMPT MSSG.
			BEQ GETPATH
			JSR COUT 		; PRINT IT
			INY 				; NEXT CHAR
			BNE @1 			; WRAPAROUND PROTECT

GETPATH:	JSR GETLN2		; GET PATHNAME FROM USER

FIX:		PHX				; SAVE LENGTH OF INPUT STRING
@1: 		LDA INBUF-1,X 	; GET LAST CHAR
			STA INBUF,X 	; MOVE OVER ONE BYTE
			DEX 				; X = X-1
			BNE @1 			; NEXT CHARACTER
			PLX 				; RETRIEVE LENGTH
			STX INBUF 		; PUT AT BEG. OF STRING

CHK1:		CPX #$04 		; 4 = LEN "QUIT"
			BNE OPEN 		; IT'S Nm "QUIT"

CHK2:		LDA INBUF,X 	; LAST CHAR OF INPUT
			AND #$DF 		; CONVERT TO UPPERCASE IF NEEDED
			CMP WORD-1,X 	; "QUIT"?
			BNE OPEN 		; NOPE
			DEX 				
			BNE CHK2 		; NOT DONE YET
			JMP QUIT 		; STR$ = "QUIT"

OPEN:		JSR MLI 			
			.byt $C8 		; OPEN COMMAND
			.word PARMTBL2 ; OPEN CMD TABLE
			BCC OPEN2 		; NO ERROR
			JSR ERROR 		; PRODOS ERROR MESSAGE
			JSR RDKEY 		; WAIT FOR A KEYPRESS
			JMP BEGIN 		; TRY AGAIN IF ERROR

OPEN2: 	LDA PARMTBL2 + 5 ; GET REFERENCE NUMBER
			STA PARMTBL3 + 1 ; STORE REF NUMBER
READ:		LDA #$04 		; # OF PARMS FOR 'READ'
			STA PARMTBL3 	; MODIFY TABLE ENTRY
			JSR MLI 			
			.byt $CA 		; READ COMMAND
			.word PARMTBL3 ; READ CMD TABLE
			BCC PRINT 		; NO ERROR

EOFCHK: 	CMP #$4C 		; ERROR = END OF FILE?
			BEQ CLOSE 		; YEP!
			JSR ERROR 		; PRODOS ERROR MSSG

PRINT: 	LDY #$00 		; INIT Y-REG
@1: 		LDA BUFFER,Y
			ORA #$80 		; SET HIGH BIT
			JSR COUT
			INY
			CPY NUMREAD 	; PRINT CHARS READ IN.
			BCC @1
			BCS READ 		; GET ANOTHER LINE OF TEXT

CLOSE: 	LDA #$01 		; REWRITE PARMTBL3
			STA PARMTBL3 	; # OF PARMS = l
			JSR MLI
			.byt $CC 			; CLOSE COMMAND
			.word PARMTBL3 	; SAME TABLE AS 'READ'
			BCC DONE 		; NO ERRORS
			JSR ERROR 		; PRODOS ERROR MSSG

DONE:		LDY #$00 		; INIT Y-REG
@1: 		LDA MSSG3,Y 	; GET CHAR TO PRINT
			BEQ D2
			JSR COUT 		; PRINT IT
			INY 				; NEXT CHAR
			BNE @1 			; WRAPAROUND PROTECT

D2:		JSR RDKEY 		; GET A KEYPRESS
			JMP BEGIN 		; BACK TO THE BEGINNING

QUIT:		JSR MLI 			; DO QUIT CALL
			.byt $65 		; QUIT CALL COMMAND VALUE
			.word PARMTBL1	; ADDRESS OF PARM TABLE
			BRK 
			BRK	 			; SHOULD NEVER GET HERE ...

ERROR: 	PHA 				; SAVE ERROR CODE
			LDY #$00 		; INIT Y-REG
@1: 		LDA MSSG2,Y 	; GET CHAR TO PRINT
			BEQ PRCODE
			JSR COUT 		; PRINT IT
			INY 				; NEXT CHAR
			BNE @1 			; WRAPAROUND PROTECT

PRCODE: 	PLA 				; RETRIEVE ERROR CODE
			JSR PRBYTE 		; PRINT IT
			LDY #$00 		; INIT Y-REG
@1: 		LDA MSSG2A,Y 	; GET CHAR TO PRINT
			BEQ ERDONE 		; END OF MSSG
			JSR COUT 		; PRINT IT
			INY 				; NEXT CHAR
			BNE @1 			; WRAPAROUND PROTECT

ERDONE: 	RTS

PARMTBL1:	.byt 4 		; NUMBER OF PARMS
			.byt 0 			; QUIT TYPE (0 = STD. QUIT)
			.word $0000 	; NOT NEEDED FOR STD. QUIT
			.byt 0 			; NOT USED AT PRESENT
			.word $0000 	; NOT USED AT PRESENT
PARMTBL2:	.byt 3 		; NUMBER OF PARMS FOR OPEN = 3
			.word INBUF 	; POINTER TO PATHNAME
			.word DOSBUF 	; POINTER TO PRODOS BUFFER
REFNUM: 	.byt 0 			; PRODOS FILE REFERENCE NUMBER
PARMTBL3:	.byt 0 		; NUMBER OF PARMS FOR READ/CWSE
			.byte 0 			; REFERENCE NUMBER
			.word BUFFER 	; POINTER TO DATA BUFFER
			.word 255 		; 255 CHARACTERS TO READ
NUMREAD: .word 0 			; NUMBER OF CHARACTERS READ.
MSSG1:   hiasc "PLEASE ENTER PATHNAME:"
			.byte $8D
			hiasc "(OR'" 
WORD:		hiasc "QUIT"
			hiasc "') "
			.byte $8D,00
MSSG2:	.byte $8D 			; PRINT RETURN FIRST
			hiasc "PRODOS ERROR $"
			.byte 00
MSSG2A: 	.byte $8D 			; ANOTHER CARRIAGE RETURN
			hiasc "PRESS A KEY TO TRY AGAIN"
			.byte 00
MSSG3: 	.byte $8D 			; PRINT RETURN FIRST ...
			hiasc "PRESS A KEY FOR NEXT FILE"
			.byte 00
CHKSUM: 		 				; CHECKSUM FOR VERIFICATION
			.align 256		; SKIP TO NEXT PAGE BOUNDARY
BUFFER: 	.byte  255 		; DATA BUFFER FOR US
DOSBUF: 						; 1024 BYTES FOR PRODOS BUFFER
								; NOT IN PROGRAM SO AS TO NOT
								; TAKE UP DISK SPACE
			.segment "INIT"
			.segment "ONCE"